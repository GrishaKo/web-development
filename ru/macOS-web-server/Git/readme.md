# Заметки по использованию Git

[Git](https://git-scm.com/) -  распределенная система управления версиями.

<!--ts-->

  * [Установка на macOS](#установка-на-macos)
  * [Ссылки](#ссылки)
  * [Использование](#использование)
     * [Вызов помощи](#вызов-помощи)
     * [Конфигурация](#конфигурация)
        * [Добавление пользователя](#добавление-пользователя)
        * [Конфигурация переноса строк](#конфигурация-переноса-строк)
        * [Настройка игнорирования файлов для текущего пользователя](#настройка-игнорирования-файлов-для-текущего-пользователя)
        * [Текстовый редактор по умолчанию](#текстовый-редактор-по-умолчанию)
        * [Алиасы](#алиасы)
        * [Просмотр конфигурации](#просмотр-конфигурации)
     * [Создание репозитория](#создание-репозитория)
     * [Запись изменений в репозиторий](#запись-изменений-в-репозиторий)
        * [Определение состояния файлов](#определение-состояния-файлов)
        * [Добавление файлов для отслеживания](#добавление-файлов-для-отслеживания)
        * [Фиксация изменений (добавление в репозиторий)](#фиксация-изменений-добавление-в-репозиторий)
        * [Игнорирование индексации](#игнорирование-индексации)
        * [Удаление файлов](#удаление-файлов)
        * [Перемещение файлов](#перемещение-файлов)
     * [Просмотр истории коммитов](#просмотр-истории-коммитов)
     * [Отмена изменений](#отмена-изменений)
     * [Работа с удаленными репозиториями](#работа-с-удаленными-репозиториями)
        * [Отображение удаленных репозиториев](#отображение-удаленных-репозиториев)
        * [Добавление удаленных репозиториев](#добавление-удаленных-репозиториев)
        * [Fetch и Pull - получение изменений из удаленного репозитория](#fetch-и-pull---получение-изменений-из-удаленного-репозитория)
        * [Push - отправка изменений в удаленный репозиторий](#push---отправка-изменений-в-удаленный-репозиторий)
        * [Удаление и переименование удаленных репозиториев](#удаление-и-переименование-удаленных-репозиториев)
     * [Работа с ветками](#работа-с-ветками)
        * [Ссылки](#ссылки-1)
        * [Создание новой ветки](#создание-новой-ветки)
        * [Просмотр веток](#просмотр-веток)
        * [Переключение веток](#переключение-веток)
        * [Основы ветвления и слияния](#основы-ветвления-и-слияния)
        * [Удаленные ветки](#удаленные-ветки)
     * [Настройка своего Git-сервера](#настройка-своего-git-сервера)
        * [Клонирование локального репозитория в новый "голый репозиторий"](#клонирование-локального-репозитория-в-новый-голый-репозиторий)
        * [Размещение "голого репозитория" на Git-сервере](#размещение-голого-репозитория-на-git-сервере)
        * [Клонирование репозитория c удаленного Git-сервера](#клонирование-репозитория-c-удаленного-git-сервера)
     * [Настройка своего Git-сервера с помощью Gitolite (предпочтительно)](#настройка-своего-git-сервера-с-помощью-gitolite-предпочтительно)
        * [Ссылки](#ссылки-2)
        * [Установка](#установка)
        * [Настройка](#настройка)
        * [Пример использования](#пример-использования)

<!-- Added by: grisha_k, at:  -->

<!--te-->

<a id="links"></a>
## Ссылки

1. [Документация](https://git-scm.com/doc) (ENG).
2. [Pro Git book v1](https://git-scm.com/book/en/v1) (ENG/[RUS](https://git-scm.com/book/ru/v1)). 
3. [Обучающий интерактивный тур](https://githowto.com/ru) (RUS).

<a id="installation"></a>
## Установка на macOS

Сначала устанавливаем [../HomeBrew](../HomeBrew/readme.md), затем с его помощью устанавливаем Git:

	$ brew install git
	$ git --version

<a id="using"></a>
## Использование

<a id="help"></a>
### Вызов помощи

По всем командам:

	$ git help

Или помощь по конкретной команде (например, log):

	$ git help log

<a id="configuration"></a>
### Конфигурация

`~/.gitconfig` - глобальный конфигурационный файл (общий для всех репозиториев) расположен в домашнем каталоге .

`.git/config` - конфигурационный файл локального репозитория, расположен в каталоге репозитория каждого проекта (например: `~/sites/localhost/.git/config`).

<a id="config-user"></a>
#### Добавление пользователя

	$ git config --global user.name "USER"
	$ git config --global user.email USER@MAIL

> `USER` - имя пользователя.
> 
> `USER@MAIL` - e-mail.

<a id="config-autocrlf"></a>
#### Конфигурация переноса строк

Преобразование переноса строк для Mac/Linux - концы строк из CRLF (\r\n) будут конвертированы в LF (\n) при отправке коммитов:

	$ git config --global core.autocrlf input

Или преобразование переноса строк для Windows - концы строк из LF будут конвертированы в CRLF при выгрузке кода:

	$ git config --global core.autocrlf true

Вывод ошибки в случае обнаружения необратимых преобразований для текущей настройки `core.autocrlf`:
	
	$ git config --global core.safecrlf true

<a id="config-gitexcludes"></a>
#### Настройка игнорирования файлов для текущего пользователя

	$ git config --global core.excludesfile ~/.gitexcludes

Далее в папке пользователя нужно создать и отредактировать файл .gitexcludes, добавив файл .DS_Store и другие необходимые файлы, каждый с новой строки:

	$ nano ~/.gitexcludes
		# добавляем строки
	.DS_Store
	.idea/

<a id="config-editor"></a>
#### Текстовый редактор по умолчанию

Устанавливаем редактор [Nano](https://en.wikipedia.org/wiki/Nano) (ENG/[RUS](https://ru.wikipedia.org/wiki/Nano)) по умолчанию для создания и редактирования сообщений коммитов и меток, лучше подходит для простых операций чем [Vim](https://en.wikipedia.org/wiki/Vim_(text_editor)) (ENG/[RUS](https://ru.wikipedia.org/wiki/Vim):

	$ git config --global core.editor "nano"

<a id="config-alias"></a>
#### Алиасы

Например, установим свою команду "git hist", которая будет выводить "git log" с дополнительными опциями: 

	$ git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"

<a id="config-list"></a>
#### Просмотр конфигурации

	$ git config --list
		# или	
	$ git config -l	

<a id="init"></a>
### Создание репозитория

Переходим в каталог проекта и далее все время работаем в нем, например:

	$ cd ~/SITES/SITE

> Знак тильда `~` - сокращенное обозначение домашнего каталога пользователя (например, выполнив в терминале `echo $HOME`, будет отображен домашний каталог `/Users/USER`, где `USER` - имя пользователя).
>  
> `SITES` - название каталога с проектами (например: `~/sites`).
> 
> `SITE` - название каталога проекта (например: `/sites/localhost`).

Создаем репозиторий (инициализируем Git):

	$ git init

> В каталоге проекта будет создан каталог репозитория `/.git` (например: `~/SITES/SITE/.git`)

<a id="recording-changes"></a>
### Запись изменений в репозиторий

<a id="git-status"></a>
#### Определение состояния файлов

	$ git status

Посмотреть, что изменили, но пока не проиндексировали:

	$ git diff

Сравнить индексированные изменения с последним коммитом:

	$ git diff --cached
		# или
	$ git diff --staged

Более подробно просмотр неиндексированных изменений:

	$ git diff	

<a id="git-add"></a>
#### Добавление файлов для отслеживания

Добавление всех файлов для отслеживания в текущем каталоге. (например: `~/Sites/localhost`):
	
	$ git add all
		# или
	$ git add .

Добавление файлов из определенного каталога (например: `~/Sites/localhost/app`):

	$ cd app
	$ git add .

Добавление одного файла:

	$ git add index.php

<a id="git-commit"></a>	
#### Фиксация изменений (добавление в репозиторий)

Только индексированных, сразу со своим комментарием:

	$ git commit -m "COMMENT"
	
> `COMMENT` - комментарий, например: First commit.

Или с использование текстового редактора:

	$ git commit

> После этого потребуется ввести свой комментарий или сохранить предложенный.
	
Если файл отслеживается, но был изменен, необходимо его сначала проиндексировать с помощью команды `git add`, либо добавить флаг `-a` для команды `commit`:  

	$ git commit -a -m "new"

<a id="gitignore"></a>	
#### Игнорирование индексации

Создаем в каталоге проекта файл для указания игнорируемых файлов и папок, которые не должны добавляться в репозиторий, и добавляемый игнорируемый каталог, например:

	$ cd ~/Sites/localhost
	$ nano .gitignore
		# добавляем строку
	/vendor

> Каталог `/vendor` будет игнорироваться при добавлении файлов на отслеживание с помощью `git add`.

<a id="rm"></a>	
#### Удаление файлов

Удаление файла из отслеживаемых при удалении из каталога (например: test.php):

	$ rm test.php
	$ git rm test.php
	$ git add .

Если файл изменили и уже проиндексировали, то необходимо использовать принудительное удаление с помощью параметра `-f`.

	$ rm test.php
	$ git rm -f test.php

Удаление файла только из индекса:

	$ git rm --cached test.php

Или группы файлов, например логи ошибок, которые забыли добавить в игнорируемые:

	$ git rm log/\*.log

<a id="mv"></a>
#### Перемещение файлов
	
	$ git mv test.php test_new.php
		# или
	$ mv test.php test_new.php
	$ git rm test.php
	$ git add test_new.php
	
> `test.php` - текущее имя файла, `test_new.php` - новое имя файла.

<a id="log"></a>
### Просмотр истории коммитов

	$ git log

Дополнительный параметр `-p` показывает внесенные изменения, также можно, например, использовать `-2`, чтобы ограничить вывод до 2-х последних записей:

	$ git log -p -2
	
Получение краткой статистик по каждому коммиту:

	$ git log --stat	

Полезный параметр `--pretty` для изменения формата вывода лога, например, для вывода каждого коммита в одну строку:

	$ git log --pretty=oneline
	
Интересный параметр — это `format`, который позволяет полностью создать собственный формат вывода лога:

	$ git log --pretty=format:"%h - %an, %ar : %s"

> [Список наиболее полезных параметров формата](https://git-scm.com/book/en/v1/Git-Basics-Viewing-the-Commit-History) (ENG/[RUS](https://git-scm.com/book/ru/v1/Основы-Git-Просмотр-истории-коммитов)) (Таблица 2-1).

Параметр добавляющий ASCII-граф, показывающий историю ветвлений и слияний:

	$ git log --pretty=format:"%h %s" --graph

Графический интерфейс:

	$ gitk

<a id="amend"></a>
### Отмена изменений

**Изменение последнего коммита:**

	$ git commit --amend

Например, если после совершения коммита вспомнили, что забыли проиндексировать изменения в файле, которые хотели добавить в этот коммит:

	$ git commit -m 'initial commit'
	$ git add FILE.txt
	$ git commit --amend
		# далее изменяем текст коммита 'initial commit'

**Отмена последнего коммита:**

	$ git reset --soft HEAD^

> `--soft` - означает, что данные удалены не будут, только коммит. Чтобы также удалить данные, необходимо использовать ключ `--hard`.

**Вернуть состояние до нужного коммита,** предварительно посмотрев список последних действий:

	$ git reflog
	$ git reset HEAD@{1}

> `{1}` - порядковый номер действия, в данном случае предыдущего коммита.

Предварительно можно переместится в состояние нужного действия, осмотреться и затем вернуться назад:

	$ git reflog
	$ git checkout 26c7ca0
	$ git checkout master

> `26c7ca0` - хэш действия.

**Отмена индексации файла**:

	$ git reset HEAD FILE.txt

Подсказка по команде отображается после выполнения команды индексации и просмотра статуса:

	$ git add .
	$ git status
	...
	(используйте «git reset HEAD <файл>…», чтобы убрать из индекса)

**Отмена изменений (безвозвратная) в файле после добавления его на отслеживание (индексации):**

	$ git checkout -- index.php

> Все изменения в файле будут возвращены в состояние, которое было сразу после индексации.

Подсказка по команде отображается после внесения изменения в отслеживаемый файл и просмотра статуса:

	$ git status
	...
	(используйте «git checkout -- <файл>…», чтобы отменить изменения

<a id="remotes"></a>
### Работа с удаленными репозиториями

Если удаленный репозиторий был клонирован, то он автоматически добавляется с именем `origin` и локальная ветка `master` будет добавлена для отслеживания удаленной ветки `origin/master`.

<a id="remote"></a>
#### Отображение удаленных репозиториев

Посмотреть сокращенные названия репозиториев:

	$ git remote

Просмотр сокращенных названий репозиториев и соответствующих им Url:

	$ git remote -v

Инспекция удаленного репозитория:

	$ git remote show origin

> `origin` - сокращенное название удаленного репозитория.

<a id="remote-add"></a>
#### Добавление удаленных репозиториев

Добавляем удаленный репозиторий origin:

	$ git remote add origin https://github.com/user/test.git

> `test.git` - название удаленного репозитория на Git-сервере (в конце .git).

<a id="fetch-pull"></a>
#### Fetch и Pull - получение изменений из удаленного репозитория

**Получаем изменения из удаленного репозитория:***

	$ git fetch origin
	
> Данные будут скопированы в локальный репозиторий в каталоге проекта (например: `~/Sites/localhost/.git`), но не будут слиты с текущей веткой (например: master), т.е. данные в каталоге проекта не будут изменены.

**Теперь можно посмотреть изменения**, т.е. какие именно коммиты сейчас отделяют локальный указатель от указателя, полученного из удаленного репозитория: 

	$ git log master..origin/master
		# или
	$ git log master..origin/master

> `master` - текущая локальная ветка.
> 
> `origin/master` - удаленный репозиторий/ветка.

Посмотреть расширенную информацию можно с помощью добавления флага `-p`, т.е. какие именно изменения произошли и в каких файлах:

	$ git log -p master origin/master

Или можно посмотреть только изменения, без коммитов:

	$ git diff master..origin/master

**Когда мы готовы принять изменения, необходимо выполнить слияние**:

	$ git merge origin/master
	
> Т.е. мы сливаем изменения в удаленном репозитории origin и ветке master, с текущей локальной веткой master (при условии что выбрана эта метка или мы не создавали других меток).

**Получить изменения и сразу выполнить слияние можно одной командой:**

	$ git pull origin master

>  Полученные изменения из удаленного репозитория origin и ветки master, будут слиты с текущей локальной веткой master.

Можно установить информацию об отслеживаемой ветке в удаленном репозитории (автоматически добавляется при клонировании репозитория):

	$ git branch --set-upstream-to=origin/master master

Просмотреть отслеживаемые ветки:

	$ git branch -vv	
	
Тогда при получения изменений, можно не указывать удаленный репозиторий и ветку: 

	$ git pull

<a id="push"></a>
#### Push - отправка изменений в удаленный репозиторий

	$ git push origin master

> Отправка изменений в удаленный репозиторий `origin` локальной ветки `master` (что означает "возьми мою локальную ветку master и обнови ей удаленную ветку master").

Чтобы отправить локальную ветку (`master`) на удаленный сервер в другую ветку (например: `master2`), нужно указать имя удаленной ветки:

	$ git push origin master:master2

Можно установить внешнюю ветку как вышестоящую для этой ветки (автоматически добавляется при клонировании репозитория), тоже самое, что установить информацию об отслеживаемой ветке:

	 $ git push --set-upstream origin master

Тогда при отправке изменений, можно не указывать удаленный репозиторий и ветку: 

	$ git push

<a id="remote-rename"></a>
#### Удаление и переименование удаленных репозиториев

Переименование:

	$ git remote rename origin origin_new

Удаление:

	$ git remote rm origin

Изменение URL:

	$ git remote set-url origin https://github.com/user/test2.git

<a id="branches"></a>
### Работа с ветками

Как минимум стоит сразу разделить проект на две ветки: master (главная ветка) и develop (ветка разработки).

<a id="branches-links"></a>
#### Ссылки

1. [A successful Git branching model](http://nvie.com/posts/a-successful-git-branching-model/) (ENG).
2. [Удачная модель ветвления для Git](https://m.habr.com/post/106912/) (RUS).

<a id="branch-develop"></a>
#### Создание новой ветки

Создадим новую ветку разработки:

	$ git branch develop
	
Если мы инициализируем пустой репозиторий, то сначала должны выполнить первый коммит:

	$ cd ~/Sites
	$ mkdir test
	$ cd test
	$ git init
	$ echo "# Index" > index.md
		# или
		# $ nano > index.md
		# # Index
	$ git add .
	$ git commit -m "init"

<a id="branch"></a>
#### Просмотр веток

Посмотреть список имеющихся веток:
	
	$ git branch
	develop
	* master

> Символ `*`, стоящий перед веткой master, указывает на ветку, на которой вы находитесь в настоящий момент.

Посмотреть последний коммит на каждой из веток:
	
	$ git branch -v

Посмотреть на какую ветку указывает HEAD:

	$ git log --oneline --decorate
	df6b504 (HEAD -> master, develop) init
	
> `HEAD` указывает на ветки `master` и `develop`, для которых последний коммит `init`.
	
<a id="checkout-develop"></a>	
#### Переключение веток

	$ git checkout develop
	$ git branch
	* develop
	master

Внесем и зафиксируем изменение:

	$ echo -e "\nDevelop" >> index.md
	$ git commit -a -m 'update index'
	
Посмотрим на какую ветку теперь указывает HEAD:

	$ git log --oneline --decorate
	f8648f2 (HEAD -> develop) update index
	df6b504 (master) init
	
> `HEAD` указывает теперь на ветку `develop`, для которой последний коммит `update index`
	
Переключимся обратно на ветку `master`:

	$ git checkout master
	
> Эта команда сделала две вещи. Она переместила указатель `HEAD` назад на ветку `master` и вернула файлы в рабочем каталоге в то состояние, которое было сохранено в снимке (snapshot), на который указывает ветка. Это также означает, что все изменения, вносимые с этого момента, будут отнесены к старой версии проекта. Другими словами, откатилась вся работа, выполненная в ветке `develop`.

Сделаем еще несколько изменений и очередной коммит:

	$ > readme.md
		# или
		# cat > readme.md ''
	$ git add .
	$ echo -e "\nMaster" >> index.md
	$ git commit -a -m 'update index'

> Теперь история проекта разделилась. Мы создали ветку `develop`, переключились в нее, поработали, а затем вернулись в основную ветку master и поработали в ней. Эти изменения изолированы друг от друга: мы можем свободно переключаться туда и обратно, а когда будем готовы — сольем их вместе.
	
Посмотрим историю наших коммитов и увидем, где находятся указатели веток, и как ветвилась история проекта:
	
	$ git log --oneline --decorate --graph --all
	* 109bbee (HEAD -> master) update index
	| * f8648f2 (develop) update index
	|/  
	* df6b504 init

<a id="branching"></a>	
#### Основы ветвления и слияния

Посмотреть ветки которые слили и не слили:

	$ git branch --merged
	$ git branch --no-merged
	
**Создадим новую ветку исправлений**, сразу выберем ее и внесем необходимые изменения:

	$ git checkout -b hotfix-0.1.1
	$ echo "# Test version 0.1.1" > readme.md
	$ git commit -a -m 'Bumped version number to 0.1.1'

Внесем исправление:
	
	$ git mv readme.md README.md	
	$ git commit -a -m 'rename readme'
	
Закроем ветку исправлений, начав с переключения обратно на ветку `master`, выполним слияние с веткой исправлений и пометим новую версию тегом:

	$ git checkout master
	$ git merge --no-ff hotfix-0.1.1
	$ git tag -a 0.1.1
	
> Флаг `--no-ff` вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может быть осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, и группирует вместе все внесенные изменения. 
> 
> Fast-forward (перемотка) означает что коммит, на который указывала ветка, которую мы слили, был прямым потомком того коммита, на котором мы находились, Git просто переместил указатель ветки вперед (так как нет разветвления в работе).

Теперь мы можем отправить изменения в удаленный репозиторий и метку версии:

	$ git push origin master 0.1.1

> `0.1.1` - метка версии, ее необходимо обязательно указывать, чтобы передать в удаленный репозиторий.

Затем вольем исправление в ветку разработки `develop`:

	$ git checkout develop
	$ git merge --no-ff hotfix-0.1.1
	Автослияние index.md
	КОНФЛИКТ (содержимое): Конфликт слияния в index.md
	Не удалось провести автоматическое слияние; исправьте конфликты и сделайте коммит результата.

> Так как до этого у нас было разветвление ветки `master` и `develop`, потому что в каждой ветки мы создали файл `index.md` с разным содержимым, а ветку `hotfix-0.1.1` сливали с веткой `master`, у нас произошел конфликт слияния, поэтому на ветке `develop` в файл `index.md` добавлено содержимое из ветки `master`.

Теперь исправим конфликт слияния веток `develop` и `hotfix-0.1.1`, изменив содержимое файла `index.md` и сделав коммит:

	$ cat index.md
	# Index
	Develop
	<<<<<<< HEAD
	=======
	Master
	>>>>>>> hotfix-0.1.1
	$ echo -e "# Index\n\nMaster\n\nDevelop" > index.md
	$ git commit -a -m 'merge index'
	
Завершим закрытие ветки исправлений, удалив ее и отправив изменения в удаленный репозиторий:

	$ git branch -d hotfix-0.1.1
	$ git push origin develop

**Создадим новую ветку функциональности**, сразу выберем ее, добавим новую фичу в проект и вернемся обратно на ветку develop:

	$ git checkout -b feature_license develop
	$ echo 'The License' > LICENSE.md
	$ git add .
	$ git commit -m 'create license'
	$ git checkout develop

В будущем, когда мы завершим новую фичу, мы вольем ее в ветку `develop`, удалим и отправим в удаленный репозиторий:

	$ git checkout develop
	$ git merge --no-ff feature_license
	$ git branch -d feature_license
	$ git push origin develop	
	
**Создадим новую ветку релиза:** 	
	
	$ git checkout -b release-1.0 develop
	$ echo "# Test version 1.0" > readme.md
	$ git commit -a -m "Bumped version number to 1.0"

Закроем ветку релиза, начав с переключения обратно на ветку `master`, выполним слияние с веткой релиза, пометим новую версию тегом и отправив изменения в удаленный репозиторий:

	$ git checkout master
	$ git merge --no-ff release-1.0
	$ git tag -a 1.0
	$ git push origin master 1.0
	
Если забыли отправить изменения с указанием метки версии, то можно отправить все метки в удаленный репозиторий отдельной командой:

	$ git push origin --tags

Затем вольем релиз в ветку разработки `develop`:

	$ git checkout develop
	$ git merge --no-ff release-1.0
	$ git push origin develop

Завершим закрытие ветки релиза, удалив ее:
	
	$ git branch -d release-1.0
	
#### Удаленные ветки

После клонирования удаленного репозитория (или получения изменений), который содержит несколько веток, сначала мы увидим только локальную ветку `master`:

	$ git branch
	* master

Чтобы увидеть удаленные ветки, необходимо выполнить команду:

	$ git branch -a
	* master
	remotes/origin/HEAD -> origin/master
	remotes/origin/develop
	remotes/origin/master	
	
Далее необходимо перейти на удаленную ветку, чтобы перенести ее в локальные, при этом отслеживание удаленной метки будет добавлено автоматически:

	$ git checkout develop
	$ git branch -vv	

Или создать локальную ветку на основе удаленной:

	$ git checkout -b develop origin/develop
	
Если для локальной ветки необходимо изменить отслеживаемую ветку, необходимо выполнить:
	
	$ git branch -u origin/develop	
	
Удаление удаленной ветки:

	$ git push origin --delete develop
	
> Как правило, Git-сервер оставит данные на некоторое время, пока не запустится сборщик мусора.

<a id="git-server"></a>	
### Настройка своего Git-сервера

<a id="clone-bare-repository"></a>	
#### Клонирование локального репозитория в новый "голый репозиторий"

Входим в каталог проектов, например:

	$ cd ~/Sites

И клонируем репозиторий проекта с параметром `--bare`:

	$ git clone --bare SITE REPOSITORY.git

> `SITE` - название каталога проекта (например: localhost).
> 
> `REPOSITORY.git` - название нового "голого репозитория" (например: используем имя проекта localhost и добавляем в конце .git).

Примерно тоже самое, что мы просто скопируем репозиторий `~/SITE/.git` из каталога проекта в каталог проектов и переименуем его:

	$ cp -Rf ~/Sites/localhost/.git ~/repositories/localhost.git

<a id="scp-bare-repository"></a>	
#### Размещение "голого репозитория" на Git-сервере

	$ scp -r localhost.git GIT@SERVER:REPOSITORY.git

> `GIT@SERVER` - удаленный Git-сервер;
> 
> `REPOSITORY.git` - удаленный репозиторий (например: localhost).

И можем удалить локальную копию "голого репозитория":

	$ rm localhost.git

<a id="clone"></a>
#### Клонирование репозитория c удаленного Git-сервера

Теперь пользователь, имеющий доступ к Git-серверу по SSH, может клонировать удаленный репозиторий и начать работать над общим проектом.

	$ cd ~/Sites
	$ git clone GIT@SERVER:localhost.git

<a id="gitolite"></a>
### Настройка своего Git-сервера с помощью Gitolite (предпочтительно)

<a id="gitolite-links"></a>
#### Ссылки

1. [Документация](https://git-scm.com/book/en/v1/Git-on-the-Server-Gitolite) [ENG/[RUS](https://git-scm.com/book/ru/v1/Git-на-сервере-Gitolite)).
2. [Официальный сайт](http://gitolite.com/).

<a id="gitolite-installation"></a>
#### Установка

Сначала необходимо создать пользователя с именем "git" на Git-сервере (где будет размещен удаленный репозиторий).

Затем необходимо настроить [./#вход по SSH на Git-сервер по публичному ключу](../SSH/readme.md#ssh-keys-authentication) без возможности входа по паролю.

Скопировать в домашний каталог пользователя `~/git` свой публичный ключ `id_rsa_USER.pub` и переименовать его в `USER.pub` (т.е. чтобы в названии было только имя пользователя и расширение .pub):

	$ scp ~/.ssh/id_rsa_USER.pub git@SERVER:~/USER.pub

После чего зайти по SSH на сервер под именем пользователя "git":

	$ ssh git@SERVER

Далее необходимо клонировать репозиторий Gitolite и установить в домашнем каталоге:

	$ git clone git://github.com/user/gitolite
	$ gitolite/install -ln

Теперь, нужно создать каталог `/bin` в домашнем каталоге:

	$ mkdir ~/git/bin
	
Добавить `$HOME/bin` в `$PATH`:

	$ sudo nano ~/.bash_profile
		# вставляем строку
	export PATH=$PATH:$HOME/bin
		# сохраняем, выходим и выполняем	
	$ source ~/.bash_profile
	
И только после этого выполняем последнюю команду:

	$ gitolite setup -pk $HOME/USER.pub	

> В результате в домашнем каталоге будет создан новый Git-репозиторий`~/repositories/gitolite-admin`, где в дальнейшем должны размещаться все Git-репозитории.
> 
> А также будет изменен файл `~/.ssh/authorized_keys`, в который будет скопирована специальная команда Gitolite и публичный ключ `USER.pub`.

**И обязательно редактируем /.ssh/authorized_keys, оставляя только ключ Gitolite, иначе при входе на сервер он не будет запускаться:**

	# gitolite start
	...
	# gitolite end

> Теперь вход на сервер по SSH будет закрыт, только те пользователи, чьи публичные ключи добавлены в конфигурацию Gitolite, смогут работать с репозиториями.

Выходим и заново заходим по SSH на сервер под именем пользователя "git", теперь мы не сможем войти на сервер, должно быть выведено сообщение, уведомляющее, что на сервере используется Gitolite, будет показаны доступные для текущего пользователя репозитории и соединение будет закрыто:

	$ ssh git@SERVER
	hello USER, this is git@SERVER running gitolite3
	R W	 gitolite-admin
	R W	 testing

<a id="gitolite-configuration"></a>
#### Настройка

Теперь на локальном компьютере необходимо клонировать репозиторий `gitolite-admin`  (например, в каталог с проектами `~/sites`), с помощью которого будет осуществляться управление доступом к репозиториям на Git-сервере:

	$ cd ~/SITES
	$ git clone git:gitolite-admin

Входим в репозиторий:

	$ cd ~/SITES/gitolite-admin
	$ ls
	conf keydir
	$ find conf keydir -type f
	conf/gitolite.conf keydir/grishak.pub
	$ cat conf/gitolite.conf
	repo gitolite-admin
	# 	RW+     =   USER
	repo testing
	# 	RW+     =   @all

> `/conf` - каталог содержит файл `gitolite.conf` для настроек уровня доступа к репозиториям.
> 
> `/keydir` - каталог содержит наш публичный ключ `USER.pub`, сюда же будет необходимо добавлять публичные ключи других пользователей (т.е. на Git-сервер их добавлять не нужно), например: `USER2.pub`.

По умолчанию для репозитория `gitolite-admin` на Git-сервере у пользователя `USER` доступ на чтение и запись (RW+). Для репозитория `testing` доступ на чтение и запись у всех пользователей (@all).

 **Теперь для того, чтобы добавить новый репозиторий на Git-сервер, нет необходимости клонировать "голый репозиторий", достаточно добавить в конфигурацию gitolite.conf права на новый репозиторий и затем добавить url на него в локальный репозиторий.**

<a id="using-gitolite"></a>
#### Пример использования

Добавляем права на управление новым репозиторием "test" в gitolite.conf:

	$ nano ~/SITES/gitolite-admin/conf/gitolite.conf
		# добавляем в конце строки
	repo test
    	RW+     =   USER

> `~/SITES` - это каталог с проектами в домашнем каталоге (например: `~/Sites`).
> 
> `test` - это название тестового репозитория.
> 
> `USER` - это имя пользователя, которое используется в названии публичного ключа в `~/Sites/gitolite-admin/keydir/USER.pub`.

И отправляем данные в удаленный репозиторий:

	$ cd ~/Sites/gitolite-admin
	$ git commit -a -m "Add new repo test"
	$ git push

> После этого на Git-сервере будет автоматически создан репозиторий `test`.

Затем создадим новый локальный проект, перейдем в него и инициализируем Git:

	$ cd ~/Sites
	$ mkdir test
	$ cd test
	$ git init
	
Создадим тестовый файл, добавим его для отслеживания и зафиксируем изменения:

	$ echo "index" > index.md
	$ git add .
	$ git commit -m "Init"

Теперь необходимо добавить URL удаленного Git-репозитория:

	$ git remote add origin git:test.git

Далее необходимо отправить изменения в новый репозиторий на Git-сервере:

	$ git push origin master
	
Теперь на другом компьютере мы можем клонировать удаленный репозиторий (для примера на локальном компьютере клонируем в другое имя проекта `test2`):

	$ cd ~/Sites
	$ git clone git:test.git test2

Создадим новый файл `test.md` и добавим его для отслеживания, затем добавим изменение в файл `index.md`, добавим в индекс все файлы и зафиксируем изменения, отправим их в удаленный репозиторий:

	$ cd test2
	$ echo "test" > test.md
	$ git add test.php
	$ echo "test2" >> index.md
	$ git commit -a -m "Update"
	$ git push

Вернемся в локальный репозиторий `test`, получим новые изменения и сольем их с веткой `master`:

	$ cd ~/Sites/test
	$ git pull origin master